{"version":3,"file":"sections.promotions.js","mappings":"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","sources":["webpack://erstwilder/webpack/runtime/chunk loaded","webpack://erstwilder/./scripts/tools/promotions/tiers.ts","webpack://erstwilder/./scripts/tools/constants/classes.ts","webpack://erstwilder/./scripts/tools/promotions/promotions.ts","webpack://erstwilder/./scripts/tools/utilities/storage-tools.ts","webpack://erstwilder/./scripts/sections/promotions.ts","webpack://erstwilder/webpack/bootstrap","webpack://erstwilder/webpack/runtime/global","webpack://erstwilder/webpack/runtime/hasOwnProperty shorthand","webpack://erstwilder/webpack/runtime/runtimeId","webpack://erstwilder/webpack/runtime/jsonp chunk loading","webpack://erstwilder/webpack/startup"],"sourcesContent":["var deferred = [];\n__webpack_require__.O = function(result, chunkIds, fn, priority) {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar chunkIds = deferred[i][0];\n\t\tvar fn = deferred[i][1];\n\t\tvar priority = deferred[i][2];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every(function(key) { return __webpack_require__.O[key](chunkIds[j]); })) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","import { LineItem, Product, Variant } from \"../../types\";\n\nexport const PROPERTY_FREE_GIFT = '_free-gift';\n\n/**\n * Tier Promotion Types\n *    This is the type of promotion tiers that the code can support\n */\nexport type TierPromotionType = 'quantity' | 'dollar';\n\n/**\n * Tier Product Data\n *    This is the product itself that tier is trying to add to cart at some\n *    point.\n */\nexport type TierProductData = {\n  handle:string;\n  variants:Variant[];\n};\n\n/**\n * Tier Data itself\n *    This is ripped straight from the section settings for the promotion\n *    section.\n */\nexport type TierData = {\n  product:string|null;\n  sku:string;\n  type:TierPromotionType;\n  inclusions:string;\n  exclusions:string;\n  min_threshold?:number|null;\n  max_threshold?:number|null;\n\n  // Note, if you need to have some kind of tier specific data, this is where\n  // you could add that. It won't affect the logic but could be used to, say\n  // for example, upsell the tiers to your customers.\n}\n\n/**\n * List of tier threshold checkers.\n * The checkers are used to \"determine how much a customer qualifies for a tier\"\n * For example, if it's a Buy X get Y, then the checker will decide that the\n * item's quantity should be used. Whereas a Spend $ get Y would instead use\n * the items' price to qualify.\n *\n * In future this could be extended further if another type were to be added.\n */\nexport const TIER_THRESHOLD_CHECKERS:{\n  [key in TierPromotionType]:(lineItem:LineItem) => number\n} = {\n  // Quantity:  Tier is met if the sum of all the qualifiying line item\n  //            quantities sums within the thresholds\n  'quantity': line => line.quantity,\n\n  // Dollar:    Tier is met if the sum of the final line prices of all the\n  //            qualifying lines sums within the thresholds\n  'dollar': line => line.final_line_price / 100\n};\n\n/**\n * Helper function to convert a CSV string into an array of strings.\n *\n * @param s A string containing CSV data.\n * @returns Array of strings that were comma separated.\n */\nconst tierFixTags = (s:string) => s\n  .split(',')\n  .map(t => t.trim())\n  .filter(n => n.replace(/\\s/gi, '').length)\n;\n\n/**\n * Get the thresholds for a tier. This will automatically correct undefined\n * thresholds.\n *\n * @param data Tier data to get the thresholds for.\n * @returns The thresholds themselves.\n */\nexport const tierGetThresholds = (data:TierData) => ({\n  min: data.min_threshold || 0,\n  max: data.max_threshold || Infinity\n});\n\n/**\n * Filters a list of items to get which lines contribute towards the tier. The\n * qualifying lines are based on the inclusions and exclusion tags within the\n * tier data (if present).\n *\n * @param data Tier data to use to get the qualifying lines for.\n * @param items Line items to filter down.\n * @param products The associated product information for each of the lines.\n * @return Only those line items that qualify.\n */\nexport const tierGetQualifyingLineItems = (\n  data:TierData, items:LineItem[], products:Product[]\n) => {\n  const inclusions = tierFixTags(data.inclusions);\n  const exclusions = tierFixTags(data.exclusions);\n\n  return items.filter(item => {\n    const product = products.find(p => p.id === item.product_id);\n\n    const isIncluded = inclusions.length ? (\n      product ? inclusions.some(tag => product.tags.includes(tag)) : false\n    ) : true;\n\n    const isExcluded = exclusions.length ? (\n      product ? exclusions.some(tag => product.tags.includes(tag)) : false\n    ) : false;\n\n    return isIncluded && !isExcluded;\n  });\n}\n\n/**\n * Returns the tier specific count for the given line items. The tier count\n * is basically the count towards the tier to qualify, e.g. if the tier is a\n * Buy X get Y then the count would be \"X\". This function aims to return that\n * \"X\".\n *\n * @param data Tier data to get the count of.\n * @param items Line items to count.\n * @param products Product information for each of the line items.\n * @returns The count towards the tier.\n */\nexport const tierGetThresholdCount = (\n  data:TierData, items:LineItem[], products:Product[]\n) => {\n  const threshCheck = TIER_THRESHOLD_CHECKERS[data.type];\n  items = tierGetQualifyingLineItems(data, items, products);\n  return (\n    items.length ? items.reduce((total,itm) => threshCheck(itm)+total, 0) : 0\n  );\n}\n\n/**\n * Returns true if the provided line items that qualify for the given tier when\n * considering the inclusions, exclusions as well as the tier type.\n *\n * @param data Tier data to get the count of.\n * @param items Line items to check.\n * @param products Product information for each of the line items.\n * @returns True if the line items are within the tiers' thresholds.\n */\nexport const tierIsWithinThresholds = (\n  data:TierData, items:LineItem[], products:Product[]\n) => {\n  const { max, min } = tierGetThresholds(data);\n  const totalValue = tierGetThresholdCount(data, items, products);\n  return totalValue >= min && totalValue <= max;\n}\n\n/**\n * Determines whether or not a customer is currently BELOW a threshold or not.\n * This is useful to determine \"can a customer keep adding to cart in order to\n * qualify for the tier\"\n *\n * @param data Tier Data to check\n * @param items Line items to use for checking.\n * @param products Product information for each of the line items.\n * @returns True if the customer is BELOW the current threshold count.\n */\nexport const tierIsBelowThreshold = (\n  data:TierData, items:LineItem[], products:Product[]\n) => {\n  const thresholds = tierGetThresholds(data);\n  const count = tierGetThresholdCount(data, items, products);\n  return count < thresholds.min;\n}\n\n/**\n * This function is designed to take in an array of tiers, return those that\n * the customer hasn't already qualified for, or superceeded, and then sort\n * those remaining tiers by the ones the customer is closest to qualifying for\n * first.\n *\n * @param data Array of tiers to check.\n * @param items Current carts' line items.\n * @param products Product data for each of the line items.\n * @returns As mentioned above.\n */\nexport const tierGetAllBelowThresholdSortedByClosest = (\n  data:TierData[], items:LineItem[], products:Product[]\n) => {\n  return data\n    .filter(tier => tierIsBelowThreshold(tier, items, products))\n    .sort((l, r) => {\n      return tierGetThresholds(r).min - tierGetThresholds(l).min;\n    })\n  ;\n}\n\n/**\n * Function to determine whether or not a given tier is already in the cart or\n * not.\n *\n * @param tier Tier to check.\n * @param tierProducts Tier's Product Data.\n * @param items Cart line items.\n * @returns True if the tier is already in the cart, otherwise false.\n */\nexport const tierIsInCart = (\n  tier:TierData, tierProducts:TierProductData, items:LineItem[]\n) => {\n  items = items.filter(item => {\n    return item.properties && item.properties[PROPERTY_FREE_GIFT];\n  });\n  if(tier.sku) items.some(item => item.sku === tier.sku);\n  return items.findIndex(item => tierProducts.variants.some(tpv => {\n    return item.variant_id === tpv.id;\n  }))\n}\n\n/**\n * Returns the variant to be selected for any given tier. This will auto match\n * on SKU if necessary.\n *\n * @param tier Tier to get the variant ID for\n * @param tierProduct Tier product data to match against.\n * @returns The variant id to be added (if applicable), otherwise null.\n */\nexport const tierGetVariantId = (\n  tier:TierData, tierProduct:TierProductData\n):number|null => {\n  let matchVariant:Variant|null = null;\n  if(tier.sku) {\n    matchVariant = tierProduct.variants.find(v => {\n      return v.available && v.sku === tier.sku\n    }) || null;\n  } else {\n    matchVariant = tierProduct.variants.find(v => v.available) || null;\n  }\n  return matchVariant ? matchVariant.id : null;\n}\n\n/**\n * Returns the product that is associated with a tier.\n *\n * @param tier Tier to get the product for.\n * @param products Array of tier data products to match against.\n * @returns The matching tier product, or null if not found.\n */\nexport const tierGetProduct = (tier:TierData, products:TierProductData[]) => {\n  if(!tier.product) return null;\n  return products.find(tp => tp.handle === tier.product) || null;\n}\n","export const CLASS_ACTIVE = 'is-active';\nexport const CLASS_OPEN = 'is-open';\nexport const CLASS_CLOSED = 'is-closed';\nexport const CLASS_HIDDEN = 'is-hidden';\nexport const CLASS_VISIBLE = 'is-visible';\nexport const CLASS_FADE_IN = 'is-fade-in';\nexport const CLASS_FADE_OUT = 'is-fade-out';\nexport const CLASS_STICKY = 'is-sticky';\nexport const CLASS_WAITING = 'is-waiting';\nexport const CLASS_FIXED = 'is-fixed';\nexport const CLASS_STUCK = 'is-stuck';\nexport const CLASS_UNAVAILABLE = 'is-unavailable';\nexport const CLASS_SELECTED = 'is-selected';\nexport const CLASS_DISABLED = 'is-disabled';\nexport const CLASS_SCROLL_DISABLED = 'is-scroll-disabled';\nexport const CLASS_HAS_ERROR = 'has-error';\nexport const CLASS_MENU_TOGGLE = 'is-menu-open';\nexport const CLASS_INITIALISED = 'is-initialised';\nexport const CLASS_SOLD_OUT = 'is-sold-out';\nexport const CLASS_PENDING = 'is-pending';\nexport const CLASS_FILTERED = 'is-filtered';\nexport const CLASS_lOADING = 'is-loading';\nexport const CLASS_DRAWER_OPEN = 'is-drawer-open';\nexport const CLASS_CART_PENDING = 'is-cart-pending';\nexport const CLASS_OVERLAY_OPEN = 'has-overlay-open';","import { cartAdd, getCart, getCurrentCart } from \"@process-creative/slate-theme-tools\";\nimport { Product, LineItem, Cart } from \"../../types/\";\nimport { getItemWithExpiry, KEY_MANUALLY_REMOVED_FREE_GIFT } from \"../utilities/storage-tools\";\nimport {\n    PROPERTY_FREE_GIFT, TierData, tierGetProduct, tierGetVariantId, tierIsInCart,\n    tierIsWithinThresholds, TierProductData\n} from \"./tiers\";\nimport { CLASS_VISIBLE } from '../constants/classes'\n\nconst SEL_PROMOTIONS = '[data-promotion-promotions]';\nconst SEL_PRODUCTS = '[data-promotion-products]';\nconst SEL_PROMO_MODAL = '[data-gwp-message]'\n/**\n * Loads the tier data from the promotion section.\n *\n * @returns The tiers defined in the section configuration.\n */\nexport const promoGetTiers = ():TierData[] => {\n  const elemPromotions = document.querySelector<HTMLScriptElement>(\n    SEL_PROMOTIONS\n  );\n  if(!elemPromotions) return [];\n  return JSON.parse(elemPromotions.innerHTML);\n}\n\n/**\n * Loads the tier product data from the promotion section.\n *\n * @returns The tier produts, as defined in the section configuration.\n */\nexport const promoGetProducts = ():TierProductData[] => {\n  const elemProducts = document.querySelector<HTMLScriptElement>(\n    SEL_PRODUCTS\n  );\n  if(!elemProducts) return [];\n  return JSON.parse(elemProducts.innerHTML);\n}\n\n/**\n * Fetch the product data for all products that are currently within the cart.\n *\n * @returns The product data for the products within the cart.\n */\nexport const promoFetchCartProducts = () => {\n  return fetch('/cart?view=products').then(e => e.json() as Promise<Product[]>);\n}\n\n/**\n * Wrapper to fetch both the cart, and the cart products at the same time.\n *\n * @returns The cart, and the product data for that cart.\n */\nexport const promoFetchCartAndProducts = async () => {\n  const cart = getCurrentCart() as Cart;\n  const cartProducts = await promoFetchCartProducts()\n  return { cart, cartProducts };\n}\n\n/**\n * Checks if a variant has already been manually removed from cart before\n * @param variantId Number of the variant id to look for in storage\n * @returns A boolean on whether the item has already been manually removed before\n */\nconst wasManuallyRemoved = (variantId:number) => {\n  const key = `${KEY_MANUALLY_REMOVED_FREE_GIFT}_${variantId}`;\n  const savedItem = getItemWithExpiry(key);\n  if(savedItem) return true;\n  return false;\n}\n\n/**\n * Essentially the bread and butter of the entire promo functionality. This will\n * check the cart state and tier data and decide which products a customer\n * should have added and/or removed and then execute those operations for you.\n *\n * Depending on the theme that is implementing this functionality you may opt to\n * then either redraw the cart for things like Cart Drawers, etc, or simply opt\n * to refresh the page whence pending complete.\n *\n * The function will return TRUE if any items were changed, or FALSE if no\n * changes to the cart were executed. This will save you fetching without any\n * cause.\n *\n * @param tiers Tier data to use for updating cart.\n * @param tierProducts Products for each of those tiers.\n * @param items Current cart state's line items.\n * @param products Current cart state's product data.\n */\nexport const promoUpdateCart = async (\n  tiers:TierData[], tierProducts:TierProductData[],\n  items:LineItem[], products:Product[]\n) => {\n  const toRemove:number[] = [];\n  const toAdd:number[] = [];\n  const gwpModal = document.querySelector<HTMLElement>(SEL_PROMO_MODAL);\n\n  // Determine products to add/remove\n  for(let i = 0; i < tiers.length; i++) {\n    const tier = tiers[i];\n\n    const tierProduct = tierGetProduct(tier, tierProducts);\n    if(!tierProduct) continue;\n\n    const variant = tierGetVariantId(tier, tierProduct);\n    if(!variant) continue;\n\n    /**\n     * If a variant (free gift) has already been manually removed, we don't\n     * want to add it back in\n     */\n    if(wasManuallyRemoved(variant)) continue;\n\n    const qualifies = tierIsWithinThresholds(tier, items, products);\n    const cartIndex = tierIsInCart(tier, tierProduct, items);\n\n    if(qualifies) {\n      if(cartIndex !== -1) continue;\n      toAdd.push(variant);\n    } else {\n      if(cartIndex === -1) continue;\n      toRemove.push(cartIndex);\n    }\n  }\n\n  // Now, make sure we don't have something that is both.. meant to be added\n  // and be removed at the same time (so we don't get in an add/remove loop)\n  const copyAdd = [ ...toAdd ];\n  for(let i = 0; i < copyAdd.length; i++) {\n    const vid = copyAdd[i];\n    let indRemove = toRemove.findIndex(toRemoveIndex => {\n      const removeVid = items[toRemoveIndex].variant_id;\n      return removeVid === vid;\n    });\n    if(indRemove === -1) continue;\n    toRemove.splice(indRemove, 1);\n    toAdd.splice(toAdd.indexOf(vid), 1);\n  }\n\n  try {\n    // Start by removing, then add. This is done because removing will change\n    // the line item indexes\n    if(toRemove.length) {\n      await fetch('/cart/update.js', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({\n          updates: items.map((li, lii) => {\n            if(toRemove.indexOf(lii) !== -1) return 0;\n            return li.quantity;\n          })\n        })\n      });\n    }\n\n    // Now add.\n    if(toAdd.length) {\n      await cartAdd({\n        items: toAdd.map(id => ({\n          id,\n          quantity: 1,\n          properties: { [PROPERTY_FREE_GIFT]: 'true' }\n        }))\n      });\n      if(gwpModal){\n        gwpModal.classList.add(CLASS_VISIBLE);\n        setTimeout(() => { gwpModal.classList.remove(CLASS_VISIBLE) }, 4000);\n      }\n    }\n\n    if(toAdd.length || toRemove.length) {\n      await getCart();\n    }\n  } catch(e) {\n    console.error(e);\n  }\n\n  return toAdd.length || toRemove.length;\n}","// Keys\nexport const KEY_MANUALLY_REMOVED_FREE_GIFT = `manuallyRemovedFreeGift`;\n\n// Helper functions\n/**\n * Saves a key/value pair into local storage with an expiry time.\n * @param key A string to use as the key for local storage\n * @param value A string value to be saved in key value pair\n * @param ttl A number to indicate the TTL on how long before the item expires\n */\nexport const setItemWithExpiry = (key:string, value:string, ttl = 604800) => {\n  // By default ttl (Time To Live) is 604800 (7 days)\n  const now = new Date();\n\n  /**\n   * `item` is an object which contains the original value\n   * as well as the time when it's supposed to expire\n   */\n  const item = {\n    value: value,\n    expiry: now.getTime() + ttl\n  };\n\n  localStorage.setItem(key, JSON.stringify(item));\n}\n\n/**\n * Retrieves an item value, but expires it first if necessary\n * @param key A string used to look for the key in local storage\n * @returns A string containing the items value or null if the item expires or\n * if there is no item to be found\n */\nexport const getItemWithExpiry = (key:string) : string|null => {\n  const itemStr = localStorage.getItem(key);\n\n  // If the item doesn't exist, return null\n  if(!itemStr) return null;\n\n  const item = JSON.parse(itemStr);\n  const now = new Date();\n\n  // Compare the expiry time of the item with the current time\n  if(now.getTime() > item.expiry) {\n    /**\n     * If the item is expired, delete the item from storage\n     * and return null\n     */\n    localStorage.removeItem(key);\n    return null;\n  }\n\n  return item.value;\n}\n","import {\n    promoFetchCartAndProducts, promoGetProducts, promoGetTiers, promoUpdateCart\n} from \"../tools/promotions/promotions\";\nimport { ON_CART_FINISHED, jq } from '@process-creative/slate-theme-tools';\n\nclass SectionPromotions {\n  private pending:boolean = false;\n\n  constructor() {\n    this.updateCartState();\n\n    document.addEventListener('onCartUpdated', this.onCartUpdated);\n    document.addEventListener('onCartModified', this.onCartUpdated);\n\n    // @ts-ignore\n    jq(document).on(ON_CART_FINISHED, (e:any) => {\n      this.updateCartState();\n    })\n  }\n\n  private onCartUpdated = () => {\n    this.updateCartState();\n  }\n\n  async updateCartState() {\n    if(this.pending) return;\n    this.pending = true;\n\n    try {\n      // Get all data necessary to update the cart information\n      const { cart, cartProducts } = await promoFetchCartAndProducts();\n      const tiers = promoGetTiers();\n      const tierProducts = promoGetProducts();\n\n      // Now update the cart\n      const changed = await promoUpdateCart(\n        tiers, tierProducts, cart.items, cartProducts\n      );\n    } catch(e) {\n      console.error(e);\n    }\n\n    this.pending = false;\n  }\n}\n\nnew SectionPromotions();","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","__webpack_require__.j = 9823;","// no baseURI\n\n// object to store loaded and loading chunks\n// undefined = chunk not loaded, null = chunk preloaded/prefetched\n// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded\nvar installedChunks = {\n\t9823: 0\n};\n\n// no chunk on demand loading\n\n// no prefetching\n\n// no preloaded\n\n// no HMR\n\n// no HMR manifest\n\n__webpack_require__.O.j = function(chunkId) { return installedChunks[chunkId] === 0; };\n\n// install a JSONP callback for chunk loading\nvar webpackJsonpCallback = function(parentChunkLoadingFunction, data) {\n\tvar chunkIds = data[0];\n\tvar moreModules = data[1];\n\tvar runtime = data[2];\n\t// add \"moreModules\" to the modules object,\n\t// then flag all \"chunkIds\" as loaded and fire callback\n\tvar moduleId, chunkId, i = 0;\n\tif(chunkIds.some(function(id) { return installedChunks[id] !== 0; })) {\n\t\tfor(moduleId in moreModules) {\n\t\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t\t}\n\t\t}\n\t\tif(runtime) var result = runtime(__webpack_require__);\n\t}\n\tif(parentChunkLoadingFunction) parentChunkLoadingFunction(data);\n\tfor(;i < chunkIds.length; i++) {\n\t\tchunkId = chunkIds[i];\n\t\tif(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {\n\t\t\tinstalledChunks[chunkId][0]();\n\t\t}\n\t\tinstalledChunks[chunkId] = 0;\n\t}\n\treturn __webpack_require__.O(result);\n}\n\nvar chunkLoadingGlobal = self[\"webpackChunkerstwilder\"] = self[\"webpackChunkerstwilder\"] || [];\nchunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));\nchunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));","// startup\n// Load entry module and return exports\n// This entry module depends on other loaded chunks and execution need to be delayed\nvar __webpack_exports__ = __webpack_require__.O(undefined, [4736], function() { return __webpack_require__(36819); })\n__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n"],"names":["deferred","PROPERTY_FREE_GIFT","TIER_THRESHOLD_CHECKERS","line","quantity","final_line_price","tierFixTags","s","split","map","t","trim","filter","n","replace","length","tierGetThresholds","data","min","min_threshold","max","max_threshold","Infinity","tierGetThresholdCount","items","products","threshCheck","type","inclusions","exclusions","item","product","find","p","id","product_id","isIncluded","some","tag","tags","includes","isExcluded","tierGetQualifyingLineItems","reduce","total","itm","tierIsWithinThresholds","totalValue","tierIsInCart","tier","tierProducts","properties","sku","findIndex","variants","tpv","variant_id","tierGetVariantId","tierProduct","matchVariant","v","available","tierGetProduct","tp","handle","CLASS_VISIBLE","i","promoFetchCartAndProducts","cart","getCurrentCart","fetch","then","e","json","cartProducts","wasManuallyRemoved","variantId","savedItem","key","itemStr","localStorage","getItem","JSON","parse","Date","getTime","expiry","removeItem","value","getItemWithExpiry","promoUpdateCart","tiers","toRemove","toAdd","gwpModal","document","querySelector","variant","qualifies","cartIndex","push","copyAdd","vid","indRemove","toRemoveIndex","splice","indexOf","method","headers","body","stringify","updates","li","lii","cartAdd","classList","add","setTimeout","remove","getCart","console","error","SectionPromotions","updateCartState","this","addEventListener","onCartUpdated","jq","on","ON_CART_FINISHED","pending","elemPromotions","innerHTML","elemProducts","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","exports","module","__webpack_modules__","call","m","O","result","chunkIds","fn","priority","notFulfilled","fulfilled","j","Object","keys","every","r","g","globalThis","Function","window","o","obj","prop","prototype","hasOwnProperty","installedChunks","chunkId","webpackJsonpCallback","parentChunkLoadingFunction","moreModules","runtime","chunkLoadingGlobal","self","forEach","bind","__webpack_exports__"],"sourceRoot":""}