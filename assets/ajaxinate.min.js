/**
 * Minified by jsDelivr using Terser v3.14.1.
 * Original file: /npm/ajaxinate@3.0.1/src/ajaxinate.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
/**
 * Minified by jsDelivr using Terser v3.14.1.
 * Original file: /npm/ajaxinate@3.0.1/src/ajaxinate.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
function Ajaxinate(options) {
  const defaults = {
    method: "scroll",
    container: "#AjaxinateContainer",
    pagination: "#AjaxinatePagination",
    offset: 0,
    loadingText: "Loading",
    callback: null
  };
  this.settings = Object.assign(defaults, options || {});
  this.cache = Object.assign({});
  
  this.addScrollListeners = this.addScrollListeners.bind(this);
  this.addClickListener = this.addClickListener.bind(this);
  this.checkIfPaginationInView = this.checkIfPaginationInView.bind(this);
  this.preventMultipleClicks = this.preventMultipleClicks.bind(this);
  this.removeClickListener = this.removeClickListener.bind(this);
  this.removeScrollListener = this.removeScrollListener.bind(this);
  this.removePaginationElement = this.removePaginationElement.bind(this);
  this.destroy = this.destroy.bind(this);
  
  this.containerElement = document.querySelector(this.settings.container);
  this.paginationElement = document.querySelector(this.settings.pagination);
  this.startFromFirst = false
  
  this.initialize();
}

Ajaxinate.prototype.initialize = function () {
  if (!this.containerElement) return;
  const methods = { click: this.addClickListener, scroll: this.addScrollListeners };
  methods[this.settings.method]();
  
  setTimeout(() => {
    const facets = document.querySelectorAll('[data-facet-checkbox]')
    const facetsBtn = document.querySelectorAll('[data-button-facet]')

    facetsBtn.forEach(btn => {
      btn.addEventListener('click', (e) => {
        this.nextPageUrl = this.cache.nextPageUrl.replace(/page=\d+/, 'page=2')
        this.cache.nextPageUrl = null
        this.startFromFirst = true
        this.loadInCache()
      })
    })
    facets.forEach(item => {
      item.addEventListener('input', (e) => {
        this.nextPageUrl = this.cache.nextPageUrl.replace(/page=\d+/, 'page=2')
        this.cache.nextPageUrl = null
        this.startFromFirst = true
        this.loadInCache()
      })
    })
  }, 1000)

  this.loadInCache();

  this.addColorNavObserver({
    observeSubtree: false,
    observeText: false,
    observeAttributes: false
  });
};

Ajaxinate.prototype.addColorNavObserver = function (options = {}) {
  try {
      const self = this;
      this.observerConfig = {
          attributes: options.observeAttributes !== false,
          childList: options.observeChildren !== false,
          subtree: options.observeSubtree !== false,
          characterData: options.observeText !== false
      };

      const selector = options.selector || '[data-faceted-nav-color]';
      
      this.observerCallback = function(mutationsList, observer) {
        mutationsList.forEach(mutation => {
          switch(mutation.type) {
            case 'childList':
              const facetsBtn = document.querySelectorAll('[data-button-facet]')
              facetsBtn.forEach(btn => {
                btn.addEventListener('click', (e) => {
                  // self.cache.nextPageUrl = document.querySelector('[data-collection-load-more]')
                  if(!self.cache.nextPageUrl) return
                  
                  self.nextPageUrl = self.cache.nextPageUrl.replace(/page=\d+/, 'page=2')
                  self.cache.nextPageUrl = null

                  self.loadInCache()
                })
              })
              break;
            case 'attributes':
              if (typeof self.onAttributeChange === 'function') {
                self.onAttributeChange(mutation);
              }
              break;
            case 'characterData':
              if (typeof self.onTextChange === 'function') {
                self.onTextChange(mutation);
              }
              break;
          }
        });
      };

      this.colorNavObserver = new MutationObserver(this.observerCallback);
      this.colorNavElement = document.querySelector(selector);

      if (!this.colorNavElement) {
        throw new Error(`Element with selector "${selector}" not found`);
      }

      this.colorNavObserver.observe(this.colorNavElement, this.observerConfig);
      
  } catch (error) {
    console.error('Error setting up ColorNav observer:', error);
  }
};

Ajaxinate.prototype.addScrollListeners = function () {
  if (this.paginationElement) {
    document.addEventListener("scroll", this.checkIfPaginationInView);
    window.addEventListener("resize", this.checkIfPaginationInView);
    window.addEventListener("orientationchange", this.checkIfPaginationInView);
  }
};

Ajaxinate.prototype.addClickListener = function () {
  if (this.paginationElement) {
    this.nextPageLinkElement = this.paginationElement.querySelector("[data-collection-load-more]");
    this.clickActive = true;
    if (this.nextPageLinkElement) {
      this.nextPageLinkElement.addEventListener("click", this.preventMultipleClicks);
    }
  }
};

Ajaxinate.prototype.preventMultipleClicks = function (event) {
  event.preventDefault();
  if (this.clickActive) {
    this.nextPageLinkElement.classList.add('loading');
    this.nextPageUrl = this.nextPageLinkElement.dataset.nextUrl;
    this.clickActive = false;
    this.loadFromCache();
  }
};

Ajaxinate.prototype.checkIfPaginationInView = function () {
  const topOffset = this.paginationElement.getBoundingClientRect().top - this.settings.offset;
  const bottomOffset = this.paginationElement.getBoundingClientRect().bottom + this.settings.offset;
  if (topOffset <= window.innerHeight && bottomOffset >= 0) {
      this.nextPageLinkElement = this.paginationElement.querySelector("[data-collection-load-more]");
      this.removeScrollListener();
      if (this.nextPageLinkElement) {
        this.nextPageLinkElement.classList.add('loading');
        this.nextPageUrl = this.nextPageLinkElement.dataset.nextUrl;
        this.loadFromCache();
      }
  }
};

Ajaxinate.prototype.loadFromCache = function() {
  if(!this.cache && this.cache.html) {
    this.loadMore()
    return;
  }
  this.containerElement.insertAdjacentHTML("beforeend", this.cache.html)
  if(!this.cache.next) {
    this.removePaginationElement()
  } else {
    this.paginationElement.innerHTML = this.cache.next
    this.initialize();
  }
  document.dispatchEvent(new CustomEvent('ajax:loaded'))
}

Ajaxinate.prototype.activeFilter = function() {
  const urlParams = new URLSearchParams(window.location.search);
  const paramsObject = Object.fromEntries(
    Array.from(urlParams.entries()).map(([key, value]) => {
      const decodedValue = decodeURIComponent(value);
      return [key, decodedValue.split(',').map(item => item.trim())];
    })
  );
  return paramsObject
}

Ajaxinate.prototype.getFilteredProduct = function(text) {
  return new Promise((resolve, reject) => {
    try {
      const parser = new DOMParser();
      const doc = parser.parseFromString(text, "text/html");

      const filter = this.activeFilter();
      if (!filter || Object.keys(filter).length === 0) {
        return resolve(text);
      }

      const productElements = doc.querySelectorAll("[data-product-thumbnail]")

      productElements.forEach(productElement => {
        const scriptElement = productElement.querySelector('[data-product-json]')
        if (!scriptElement) return

        const productData = JSON.parse(scriptElement.textContent.trim());
        let isAvailabilityMatched = true
        let isColorMatched = true
        let isTypeMatched = true

        if(filter.type) {
          isTypeMatched = filter.type.includes(productData.type)
        }

        if(filter.color) {
          const allowedColors = filter.color
          isColorMatched = productData.tags.some(tag => allowedColors.includes(tag))
        }

        if(filter.availability) {
          if(filter.availability.includes('sold-out')) {
            isAvailabilityMatched = productData.available ? false : true
          }
          if(filter.availability.includes('available')) {
            isAvailabilityMatched = productData.available ? true : false
          }
        }

        if(!isAvailabilityMatched || !isColorMatched || !isTypeMatched) {
          productElement.remove()
        }
      })

      const filteredHTML = doc.body.innerHTML;
      resolve(filteredHTML);
    } catch (error) {
      reject(error)
    }
  })
}

Ajaxinate.prototype.loadInCache = function() {
  this.request = new XMLHttpRequest();
  this.request.onreadystatechange = async function() {
    if(!this.request.responseXML) return;
    if(this.request.readyState !== 4 || this.request.status !== 200) return;

    const newContent = this.request.responseXML.querySelectorAll(this.settings.container)[0];
    const newPagination = this.request.responseXML.querySelectorAll(this.settings.pagination)[0];

    const filteredProduct = await this.getFilteredProduct(newContent.innerHTML)


    this.cache.html = filteredProduct
    if(!newPagination) {
      this.cache.next = null
      this.cache.nextPageUrl = null
    } else {
      this.cache.next = newPagination.innerHTML
      this.cache.nextPageUrl = newPagination.querySelector("[data-collection-load-more]")?.dataset?.nextUrl

      if(!this.cache.nextPageUrl) {
        this.nextPageLinkElement = this.paginationElement.querySelector("[data-collection-load-more]");
        if(this.nextPageLinkElement) {
          this.cache.nextPageUrl = this.nextPageLinkElement.dataset.nextUrl;
        }
      }
      
      if (this.settings.callback && typeof this.settings.callback === "function") {
        this.settings.callback(this.request.responseXML);
      }
    }
  }.bind(this)

  if(!this.nextPageUrl) {
    if (this.paginationElement) {
      this.nextPageLinkElement = this.paginationElement.querySelector("[data-collection-load-more]");
      if(this.nextPageLinkElement) {
        this.nextPageUrl = this.nextPageLinkElement.dataset.nextUrl;
      }
    }
  }
  const filter = this.activeFilter();

  // console.log('Request sent to: ', url, this.startFromFirst, url.replace(/page=\d+/, 'page=2'))
  const url = this.cache.nextPageUrl ? this.cache.nextPageUrl : this.nextPageUrl
  this.request.open("GET", this.cache.nextPageUrl ? this.cache.nextPageUrl : this.nextPageUrl)
  this.request.responseType = "document"
  this.request.send()
}

Ajaxinate.prototype.loadMore = function () {
  this.request = new XMLHttpRequest();
  this.request.onreadystatechange = function () {
      if (!this.request.responseXML) return;
      if (this.request.readyState !== 4 || this.request.status !== 200) return;
      const newContent = this.request.responseXML.querySelectorAll(this.settings.container)[0];
      
      const newPagination = this.request.responseXML.querySelectorAll(this.settings.pagination)[0];
      this.containerElement.insertAdjacentHTML("beforeend", newContent.innerHTML);
      if (!newPagination) {
        this.removePaginationElement();
      } else {
        this.paginationElement.innerHTML = newPagination.innerHTML;
        if (this.settings.callback && typeof this.settings.callback === "function") {
            this.settings.callback(this.request.responseXML);
        }
        this.initialize();
      }
      document.dispatchEvent(new CustomEvent('ajax:loaded'))
  }.bind(this);
  
  this.request.open("GET", this.nextPageUrl);
  this.request.responseType = "document";
  this.request.send();
};

Ajaxinate.prototype.removeClickListener = function () {
  if (this.nextPageLinkElement) {
    this.nextPageLinkElement.removeEventListener("click", this.preventMultipleClicks);
  }
};

Ajaxinate.prototype.removePaginationElement = function () {
  this.paginationElement.innerHTML = "";
  this.destroy();
};

Ajaxinate.prototype.removeScrollListener = function () {
  document.removeEventListener("scroll", this.checkIfPaginationInView);
  window.removeEventListener("resize", this.checkIfPaginationInView);
  window.removeEventListener("orientationchange", this.checkIfPaginationInView);
};

Ajaxinate.prototype.destroy = function () {
  const methods = { click: this.removeClickListener, scroll: this.removeScrollListener };
  methods[this.settings.method]();
  return this;
};

// Expose Ajaxinate globally
window.Ajaxinate = Ajaxinate;

